[
  {
    "title": "Automatically Testing String Solvers",
    "abstract": "SMT solvers are at the basis of many applications, such as program verification, program synthesis, and test case generation. For all these applications to provide reliable results, SMT solvers must answer queries correctly. However, since they are complex, highly-optimized software systems, ensuring their correctness is challenging. In particular, state-of-the-art testing techniques do not reliably detect when an SMT solver is unsound. In this paper, we present an automatic approach for generating test cases that reveal soundness errors in the implementations of string solvers, as well as potential completeness and performance issues. We synthesize input formulas that are satisfiable or unsatisfiable by construction and use this ground truth as test oracle. We automatically apply satisfiability-preserving transformations to generate increasingly-complex formulas, which allows us to detect many errors with simple inputs and, thus, facilitates debugging. The experimental evaluation shows that our technique effectively reveals bugs in the implementation of widely-used SMT solvers and applies also to other types of solvers, such as automata-based solvers. We focus on strings here, but our approach carries over to other theories and their combinations.",
    "published_date": "2020-06-27",
    "citation_count": 32,
    "url": "https://dl.acm.org/doi/10.1145/3377811.3380398"
  },
  {
    "title": "Semantic program alignment for equivalence checking",
    "abstract": "We introduce a robust semantics-driven technique for program equivalence checking. Given two functions we find a trace alignment over a set of concrete executions of both programs and construct a product program particularly amenable to checking equivalence. We demonstrate that our algorithm is applicable to challenging equivalence problems beyond the scope of existing techniques. For example, we verify the correctness of the hand-optimized vector implementation of strlen that ships as part of the GNU C Library, as well as the correctness of vectorization optimizations for 56 benchmarks derived from the Test Suite for Vectorizing Compilers.",
    "published_date": "2019-06-08",
    "citation_count": 71,
    "url": "https://dl.acm.org/doi/10.1145/3314221.3314596"
  },
  {
    "title": "An Empirical Comparison of Compiler Testing Techniques",
    "abstract": "Compilers, as one of the most important infrastructure of today's digital world, are expected to be trustworthy. Different testing techniques are developed for testing compilers automatically. However, it is unknown so far how these testing techniques compared to each other in terms of testing effectiveness: how many bugs a testing technique can find within a time limit. In this paper, we conduct a systematic and comprehensive empirical comparison of three compiler testing techniques, namely, Randomized Differential Testing (RDT), a variant of RDTâ€”Different Optimization Levels (DOL), and Equivalence Modulo Inputs (EMI). Our results show that DOL is more effective at detecting bugs related to optimization, whereas RDT is more effective at detecting other types of bugs, and the three techniques can complement each other to a certain degree. Furthermore, in order to understand why their effectiveness differs, we investigate three factors that influence the effectiveness of compiler testing, namely, efficiency, strength of test oracles, and effectiveness of generated test programs. The results indicate that all the three factors are statistically significant, and efficiency has the most significant impact.",
    "published_date": "2016-05-14",
    "citation_count": 96,
    "url": "https://dl.acm.org/doi/10.1145/2884781.2884878"
  },
  {
    "title": "Robustness testing oracle using a sequence alignment algorithm",
    "abstract": "In robustness testing, fault injection is a technique commonly used to observe software behavior submitted to stressful conditions. To check if the software reacts as expected we must use an oracle, a reference for correct system behavior. Typically, in fault injection based approaches, the oracle just verifies the result against a previous execution, without the injection of faults (golden run). This oracle may not be reliable, since the original run may contain undetected errors. This paper proposes an approach for evaluation results of robustness testing. The approach is based on passive testing technique, in which the system execution is monitored to collect an execution trace; then the trace is analyzed to determine whether it satisfies desired properties or not. This analysis can be performed using pattern matching algorithms, where the pattern, represented by the desired property, is matched against the execution trace. In the proposed approach the pattern matching algorithm commonly used for pairwise alignment of biological sequences was adapted to process robustness testing results. We chose local alignment technique and predefined scoring function to implement the alignment between the trace and desired behavior. The adaptation of sequence alignment algorithms in this different context is promising. We present the results of experiments performed using different scoring functions.",
    "published_date": "2010-07-13",
    "citation_count": 2,
    "url": "https://dl.acm.org/doi/10.1145/1868048.1868051"
  },
  {
    "title": "Post-mortem black-box correctness tests for basic parallel data structures",
    "abstract": "Operations on basic data structures such as queues, priority queues, stacks, and counters can dominate the execution time of a parallel program due to their frequency and their coordination and contention overheads. There are considerable performance payoffs in developing highly-optimized, asynchronous, distributed, cache-conscious, parallel implementations of such data structures. Such implementations may employ a variety of tricks to reduce latencies and avoid serial bottlenecks, as long as the semantics of the data structure are preserved. The complexity of the implementation and the difficulty in reasoning about asynchronous systems increases concerns regarding possible bugs in the implementation. In this paper, we consider black box procedures for testing whether a parallel data structure behaved correctly. We present the first systematic study of algorithms and hardness results for such testing procedures, focusing on queues, priority queues, stacks, and counters, under various important scenarios. Our results demonstrate the importance of selecting test data such that distinct values are inserted into the data structure (as appropriate). In such cases, we present an O(n) time algorithm for testing linearizable queues, an O(nlog n) time algorithm for testing linearizable priority queues, and an O(np') time algorithm for testing non-linearizable queues, where n is the number of data structure operations and p is the number of processors. In contrast, we show that testing such data structures for executions with arbitrary input values is NP-complete. Our results also help clarify the thresholds between scenarios that admit polynomial time solutions and those that are NPcomplete. Our algorithms are the first nontrivial algorithms for these problems. *Bell Laboratories, Lucent Technologies, Room 2A-341, 600 Mountain Avenue, Murray Hill NJ 07974. gibbons@research.bell-labs.com +Dept. of Comp uter Science, University of California, Santa Barbara CA 93106. bruno@cs.ucsb.edu. This work was performed while the author was visiting Bell Labs. *AT&T Labs Research, Florham Park NJ 07932. phillips@research.att.com P,amission to makr digital or hard copies oral1 07 part oCthis WN'~ fi)r pcrsonal or classroom use is granted without fee provided that COPiCs are not mac{e or distributed for profit or commercial advatltage and that copies bear this notice alld Ihe full citation 011 the first page. To COPY otherwise, to republish, to post on seners 01' to redistchute to lists. requires prior spccitic permission and/or a fee. SPAA '99 Saint Malo, France Cop,,,@ ACM 1999 I-581 13-124-0/99/06...$5.00",
    "published_date": "1999-06-01",
    "citation_count": 1,
    "url": "https://dl.acm.org/doi/10.1145/305619.305625"
  }
]