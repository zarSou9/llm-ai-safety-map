[
  {
    "url": "https://arxiv.org/pdf/2106.05864.pdf",
    "title": "Verifiable and Compositional Reinforcement Learning Systems",
    "published_date": "2021-06-07",
    "abstract": "We propose a framework for verifiable and compositional reinforcement learning (RL) in which a collection of RL subsystems, each of which learns to accomplish a separate subtask, are composed to achieve an overall task. The framework consists of a high-level model, represented as a parametric Markov decision process (pMDP) which is used to plan and to analyze compositions of subsystems, and of the collection of low-level subsystems themselves. By defining interfaces between the subsystems, the framework enables automatic decompositions of task specifications, e.g., reach a target set of states with a probability of at least 0.95, into individual subtask specifications, i.e. achieve the subsystem's exit conditions with at least some minimum probability, given that its entry conditions are met. This in turn allows for the independent training and testing of the subsystems; if they each learn a policy satisfying the appropriate subtask specification, then their composition is guaranteed to satisfy the overall task specification. Conversely, if the subtask specifications cannot all be satisfied by the learned policies, we present a method, formulated as the problem of finding an optimal set of parameters in the pMDP, to automatically update the subtask specifications to account for the observed shortcomings. The result is an iterative procedure for defining subtask specifications, and for training the subsystems to meet them. As an additional benefit, this procedure allows for particularly challenging or important components of an overall task to be identified automatically, and focused on, during training. Experimental results demonstrate the presented framework's novel capabilities in both discrete and continuous RL settings. A collection of RL subsystems are trained, using proximal policy optimization algorithms, to navigate different portions of a labyrinth environment. A cross-labyrinth task specification is then decomposed into subtask specifications. Challenging portions of the labyrinth are automatically avoided if their corresponding subsystems cannot learn satisfactory policies within allowed training budgets. Unnecessary subsystems are not trained at all. The result is a compositional RL system that efficiently learns to satisfy task specifications.",
    "citation_count": 15,
    "summary": "This paper presents a framework for verifiable and compositional reinforcement learning, enabling the decomposition of complex tasks into subtasks with guaranteed overall task satisfaction through independent subsystem training and iterative subtask specification refinement. The framework uses a high-level parametric Markov decision process to plan and analyze compositions, ensuring that successful subtask policies guarantee overall task success."
  },
  {
    "url": "https://arxiv.org/pdf/2306.17033.pdf",
    "title": "Safety-Aware Task Composition for Discrete and Continuous Reinforcement Learning",
    "published_date": "2023-06-29",
    "abstract": "Compositionality is a critical aspect of scalable system design. Reinforcement learning (RL) has recently shown substantial success in task learning, but has only recently begun to truly leverage composition. In this paper, we focus on Boolean composition of learned tasks as opposed to functional or sequential composition. Existing Boolean composition for RL focuses on reaching a satisfying absorbing state in environments with discrete action spaces, but does not support composable safety (i.e., avoidance) constraints. We advance the state of the art in Boolean composition of learned tasks with three contributions: i) introduce two distinct notions of safety in this framework; ii) show how to enforce either safety semantics, prove correctness (under some assumptions), and analyze the trade-offs between the two safety notions; and iii) extend Boolean composition from discrete action spaces to continuous action spaces. We demonstrate these techniques using modified versions of value iteration in a grid world, Deep Q-Network (DQN) in a grid world with image observations, and Twin Delayed DDPG (TD3) in a continuous-observation and continuous-action Bullet physics environment. We believe that these contributions advance the theory of safe reinforcement learning by allowing zero-shot composition of policies satisfying safety properties.",
    "summary": "This paper introduces two novel safety notions for Boolean composition of reinforcement learning tasks, proving their correctness and extending their application from discrete to continuous action spaces. The authors demonstrate these techniques using various RL algorithms across different environments, enabling zero-shot composition of safe policies."
  },
  {
    "url": "https://arxiv.org/abs/2203.02461",
    "title": "A Theory of Composing Protocols",
    "published_date": "2022-03-04",
    "abstract": "In programming, protocols are everywhere. Protocols describe the pattern of interaction (or communication) between software systems, for example, between a user-space program and the kernel or between a local application and an online service. Ensuring conformance to protocols avoids a significant class of software errors. Subsequently, there has been a lot of work on verifying code against formal protocol specifications. The pervading approaches focus on distributed settings involving parallel composition of processes within a single monolithic protocol description. However we observe that, at the level of a single thread/process, modern software must often implement a number of clearly delineated protocols at the same time which become dependent on each other, e.g., a banking API and one or more authentication protocols. Rather than plugging together modular protocol-following components, the code must re-integrate multiple protocols into a single component. We address this concern of combining protocols via a novel notion of 'interleaving' composition for protocols described via a process algebra. User-specified, domain-specific constraints can be inserted into the individual protocols to serve as 'contact points' to guide this composition procedure, which outputs a single combined protocol that can be programmed against. Our approach allows an engineer to then program against a number of protocols that have been composed (re-integrated), reflecting the true nature of applications that must handle multiple protocols at once. We prove various desirable properties of the composition, including behaviour preservation: that the composed protocol implements the behaviour of both component protocols. We demonstrate our approach in the practical setting of Erlang, with a tool implementing protocol composition that both generates Erlang code from a protocol and generates a protocol from Erlang code. This tool shows that, for a range of sample protocols (including real-world examples), a modest set of constraints can be inserted to produce a small number of candidate compositions to choose from. As we increasingly build software interacting with many programs and subsystems, this new perspective gives a foundation for improving software quality via protocol conformance in a multi-protocol setting.",
    "citation_count": 1,
    "summary": "This paper introduces a novel \"interleaving\" composition for process algebra-described protocols, enabling the integration of multiple protocols within a single software component by using user-specified constraints as contact points, thus improving software quality through enhanced protocol conformance in multi-protocol settings. The approach is demonstrated with an Erlang tool that generates and analyzes protocol code, ensuring behavioral preservation of the component protocols."
  },
  {
    "url": "https://arxiv.org/abs/2202.01830",
    "title": "Modularization, Composition, and Hierarchization of Petri Nets with Heraklit",
    "published_date": "2022-02-03",
    "abstract": "It is known for decades that computer-based systems cannot be understood without a concept of modularization and decomposition. We suggest a universal, expressive, intuitively attractive composition operator for Petri nets, combined with a refinement concept and an algebraic representation of nets and their composition. Case studies show exemplarily, how large systems can be composed from tiny net snippets. In the future, more field studies are needed to better understand the consequences of the proposed ideas in the real world.",
    "citation_count": 1,
    "summary": "Heraklit, a new approach to Petri net modeling, introduces a compositional operator enabling the modular construction of complex systems from smaller, simpler nets through refinement and an algebraic representation. Further research is needed to assess its real-world applicability."
  },
  {
    "url": "https://arxiv.org/abs/2212.02618",
    "title": "Collabs: A Flexible and Performant CRDT Collaboration Framework",
    "published_date": "2022-12-05",
    "abstract": "A collaboration framework is a distributed system that serves as the data layer for a collaborative app. Conflict-free Replicated Data Types (CRDTs) are a promising theoretical technique for implementing collaboration frameworks. However, existing frameworks are inflexible: they are often one-off implementations of research papers or only permit a restricted set of CRDT semantics, and they do not allow app-specific optimizations. Until now, there was no general framework that lets programmers mix, match, and modify CRDTs. We solve this with Collabs, a CRDT-based collaboration framework that lets programmers implement their own CRDTs, either from-scratch or by composing existing building blocks. Collabs prioritizes both semantic flexibility and performance flexibility: it allows arbitrary app-specific CRDT behaviors and optimizations, while still providing strong eventual consistency. We demonstrate Collabs's capabilities and programming model with example apps and CRDT implementations. We then show that a collaborative rich-text editor using Collabs's built-in CRDTs can scale to over 100 simultaneous users, unlike existing CRDT frameworks and Google Docs. Collabs also has lower end-to-end latency and server CPU usage than a popular Operational Transformation framework, with acceptable CRDT metadata overhead.",
    "citation_count": 2,
    "summary": "Collabs is a flexible and performant CRDT-based collaboration framework that allows programmers to easily create and customize CRDTs, enabling both app-specific optimizations and strong eventual consistency. Its scalability and performance surpass existing CRDT frameworks and even some operational transformation systems."
  },
  {
    "url": "https://www.lesswrong.com/posts/xmWfNDnEf36yQBLY9/to-make-better-software-do-what-artists-do",
    "author": "matto",
    "title": "To Make Better Software, Do What Artists Do",
    "published_date": "2022-04-01",
    "summary": "The author argues that software development is better understood as a compositional art, like writing, rather than engineering. This artistic approach emphasizes skillful arrangement of code, leading to higher quality, more maintainable software, unlike the often-flawed results of the prevalent engineering metaphor."
  },
  {
    "url": "https://www.lesswrong.com/posts/zihNijSp2aMCL4Rho/axis-oriented-programming",
    "author": "Donald Hobson",
    "title": "Axis oriented programming",
    "published_date": "2022-04-20",
    "summary": "This article proposes a new array-oriented programming language where data is inherently multi-dimensional, with axes explicitly defined and managed. The language aims to simplify handling high-dimensional arrays by providing functions for operations like summing along specific axes and sorting lexicographically across multiple axes, while employing compiler optimizations to efficiently manage potentially large arrays."
  },
  {
    "url": "https://www.lesswrong.com/posts/TcwavPJ2Qivcdphfd/compositionality-sql-and-subways",
    "author": "DanB",
    "title": "Compositionality: SQL and Subways",
    "published_date": "2021-07-19",
    "summary": "The article defines software compositionality as a system of tools exhibiting parsimony, efficiency, interoperability, and practicality. It uses the Unix philosophy and its command-line tools as an example, highlighting their strengths and limitations in achieving true compositional power."
  }
]